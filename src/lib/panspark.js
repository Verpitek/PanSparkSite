var l=new Map,b=new Map,m=[],h;((o)=>{o[o.SET=0]="SET";o[o.MATH=1]="MATH";o[o.PRINT=2]="PRINT";o[o.IF=3]="IF";o[o.JUMP=4]="JUMP";o[o.POINT=5]="POINT";o[o.END=6]="END";o[o.MEMVIPE=7]="MEMVIPE";o[o.MEMDUMP=8]="MEMDUMP";o[o.SIGNAL=9]="SIGNAL";o[o.RETURN=10]="RETURN"})(h||={});function i(u,a){let e=l.get(u);if(e!==void 0)return e;else{let n=0;try{n=Number(u)}catch(t){throw new Error("variable "+u+" is not a number at line "+a)}return n}}function N(u,a){if(b.has(u)){let e=b.get(u);if(e!=null)return[!0,e];else throw new Error("jump point "+u+" is not defined at line "+a)}else throw new Error("jump point "+u+" is not defined at line "+a)}function f(u){let a=u.split(`
`),e=[];for(let n=0;n<a.length;n++){let t=a[n].trimLeft();if(t.trim()===""||t.startsWith("//"))continue;let r=t.split(" "),s=h[r[0].toUpperCase()];e.push({operation:s,args:r.slice(1),line:n+1})}return e}async function p(u){for(let a=0;a<u.length;a++){let e=u[a];if(e.operation===5)b.set(e.args[0],a)}e:for(let a=0;a<u.length;a++){let e=u[a];switch(e.operation){case 0:{let n=i(e.args[0],e.line);if(n!==void 0&&!Number.isNaN(n))l.set(e.args[2],n);else throw new Error("Invalid variable name at line "+e.line);break}case 2:{let n=e.args[0],t=i(e.args[0],e.line);if(Number.isNaN(t))throw new Error("Invalid print operation at line "+e.line);else m.push(t.toString());break}case 1:{let n=e.args;switch(n[1]){case"+":{let t=i(n[0],e.line),r=i(n[2],e.line),s=t+r;if(Number.isNaN(s))throw new Error("Invalid operation at line "+e.line);else l.set(n[4],t+r);break}case"-":{let t=i(n[0],e.line),r=i(n[2],e.line),s=t-r;if(Number.isNaN(s))throw new Error("Invalid operation at line "+e.line);else l.set(n[4],s);break}case"*":{let t=i(n[0],e.line),r=i(n[2],e.line),s=t*r;if(Number.isNaN(s))throw new Error("Invalid operation at line "+e.line);else l.set(n[4],s);break}case"/":{let t=i(n[0],e.line),r=i(n[2],e.line),s=t/r;if(Number.isNaN(s))throw new Error("Invalid operation at line "+e.line);else l.set(n[4],s);break}case"%":{let t=i(n[0],e.line),r=i(n[2],e.line),s=t%r;if(Number.isNaN(s))throw new Error("Invalid operation at line "+e.line);else l.set(n[4],s);break}case"**":{let t=i(n[0],e.line),r=i(n[2],e.line),s=Math.pow(t,r);if(Number.isNaN(s))throw new Error("Invalid operation at line "+e.line);else l.set(n[4],s);break}case"sqrt":{let t=i(n[0],e.line),r=Math.sqrt(t);if(Number.isNaN(r))throw new Error("Invalid operation at line "+e.line);else l.set(n[3],r);break}case"log":{let t=i(n[0],e.line),r=Math.log(t);if(Number.isNaN(r))throw new Error("Invalid operation at line "+e.line);else l.set(n[3],r);break}case"rand":{let t=i(n[0],e.line),r=Math.random()*t;if(Number.isNaN(r))throw new Error("Invalid operation at line "+e.line);else l.set(n[3],r);break}case"floor":{let t=i(n[0],e.line),r=Math.floor(t);if(Number.isNaN(r))throw new Error("Invalid operation at line "+e.line);else l.set(n[3],r);break}case"ceil":{let t=i(n[0],e.line),r=Math.ceil(t);if(Number.isNaN(r))throw new Error("Invalid operation at line "+e.line);else l.set(n[3],r);break}case"sin":{let t=i(n[0],e.line),r=Math.sin(t);if(Number.isNaN(r))throw new Error("Invalid operation at line "+e.line);else l.set(n[3],r);break}default:throw new Error("invalid math operator at line "+e.line)}break}case 3:{let n=e.args;switch(n[1]){case">":{let t=i(n[0],e.line),r=i(n[2],e.line),s=t>r;if(Number.isNaN(t)||Number.isNaN(r))throw new Error("invalid > comparison at line "+e.line);else if(s){let c=N(n[4],a);if(c[0]===!0)a=c[1]}break}case"<":{let t=i(n[0],e.line),r=i(n[2],e.line),s=t<r;if(Number.isNaN(t)||Number.isNaN(r))throw new Error("invalid < comparison at line "+e.line);else if(s){let c=N(n[4],a);if(c[0]===!0)a=c[1]}break}case"==":{let t=i(n[0],e.line),r=i(n[2],e.line),s=t==r;if(Number.isNaN(t)||Number.isNaN(r))throw new Error("invalid == comparison at line "+e.line);else if(s){let c=N(n[4],a);if(c[0]===!0)a=c[1]}break}case"!=":{let t=i(n[0],e.line),r=i(n[2],e.line),s=t!=r;if(Number.isNaN(t)||Number.isNaN(r))throw new Error("invalid != comparison at line "+e.line);else if(s){let c=N(n[4],a);if(c[0]===!0)a=c[1]}break}case">=":{let t=i(n[0],e.line),r=i(n[2],e.line),s=t>=r;if(Number.isNaN(t)||Number.isNaN(r))throw new Error("invalid >=comparison at line "+e.line);else if(s){let c=N(n[4],a);if(c[0]===!0)a=c[1]}break}case"<=":{let t=i(n[0],e.line),r=i(n[2],e.line),s=t<=r;if(Number.isNaN(t)||Number.isNaN(r))throw new Error("invalid <=comparison at line "+e.line);else if(s){let c=N(n[4],a);if(c[0]===!0)a=c[1]}break}default:throw new Error("invalid comparison operator at line "+e.line)}break}case 5:break;case 6:break e;case 4:{let n=N(e.args[0],a);if(n[0]===!0)a=n[1];break}case 7:{l.clear();break}case 8:{m.push(`>>> MEMORY DUMP (Line ${e.line} at ${new Date().toLocaleTimeString()} <<<`);for(let[t,r]of l.entries())m.push(`var ${t}: ${r}`);for(let[t,r]of b.entries())m.push(` jump ${t}: ${r}`);m.push(`Iteration: ${a} TotalVars: ${l.size} TotalJumps: ${b.size} `),m.push(">>> End of MEMDUMP <<<");break}case 10:{let n=i(e.args[0],e.line);if(Number.isNaN(n))throw new Error("Invalid return operation at line "+e.line);else return n}default:m.push("Invalid operation");break}}return 0}function g(){l.clear(),b.clear(),m=[]}export{p as run,g as resetVM,f as compile,m as buffer};
