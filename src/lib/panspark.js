var T;((D)=>{D[D.SET=0]="SET";D[D.MATH=1]="MATH";D[D.PRINT=2]="PRINT";D[D.ECHO=3]="ECHO";D[D.POINT=4]="POINT";D[D.JUMP=5]="JUMP";D[D.IF=6]="IF";D[D.END=7]="END";D[D.RETURN=8]="RETURN";D[D.CALL=9]="CALL";D[D.PROC=10]="PROC";D[D.WAIT=11]="WAIT";D[D.INC=12]="INC";D[D.DEC=13]="DEC";D[D.FREE=14]="FREE";D[D.NOP=15]="NOP";D[D.MEMDUMP=16]="MEMDUMP";D[D.TICK=17]="TICK";D[D.IMPORT=18]="IMPORT";D[D["}"]=19]="}"})(T||={});class U{jumpPoints=new Map;procPoints=new Map;variableMemory=new Map;buffer=[];procLock=!1;procVariableMemory=new Map;procArgs=[];procLastLocation=0;procReturn=0;procReturnValueTarget=null;waitTicks=0;counter=0;customOpCodes=new Map;importedModules=new Set;constructor(){}registerOpCode(I,q){this.customOpCodes.set(I.toUpperCase(),q)}setVariableMemory(I,q){if(this.procLock){this.procVariableMemory.set(I,q);return}this.variableMemory.set(I,q)}variableCheck(I,q){if(this.procLock){let H=this.procVariableMemory.get(I);if(H!==void 0)return H}let f=this.variableMemory.get(I);if(f!==void 0)return f;let F=Number(I);if(!isNaN(F))return F;throw new Error(`Variable "${I}" is not defined at line ${q}`)}jumpPointCheck(I,q){let f=this.jumpPoints.get(I);if(f===void 0)throw new Error(`Jump point "${I}" is not defined at line ${q}.`);return f}procPointCheck(I,q){let f=this.procPoints.get(I);if(f===void 0)throw new Error(`Proc "${I}" is not defined at line ${q}.`);return f}compile(I){let q=I.split(`
`),f=[];this.jumpPoints.clear(),this.procPoints.clear();for(let G=0;G<q.length;G++){let K=q[G].trim();if(K===""||K.startsWith("//"))continue;let Q=/"([^"]*)"|\[([^\]]*)\]|\s*>>\s*(\S+)|\(([^)]*)\)|(\S+)/g,L=[],z;while((z=Q.exec(K))!==null)if(z[1]!==void 0)L.push(z[1]);else if(z[2]!==void 0)L.push(`${z[2]}`);else if(z[3]!==void 0)L.push(">>",z[3]);else if(z[4]!==void 0)L.push(z[4]);else L.push(z[5]);let J=L[0].toUpperCase(),R=T[L[0].toUpperCase()];if(R===void 0&&this.customOpCodes.has(J))R=J;if(R===void 0)R=J;f.push({operation:R,args:L.slice(1),line:G+1})}for(let G=0;G<f.length;G++){let K=f[G];if(K.operation===4)this.jumpPoints.set(K.args[0],G)}let F={name:"",startLine:0,endLine:0},H=!1;for(let G=0;G<f.length;G++){let K=f[G];if(!H){if(K.operation===10)F={name:K.args[0],startLine:G,endLine:0},H=!0}if(K.operation===19)F.endLine=G,this.procPoints.set(F.name,[F.startLine,F.endLine]),H=!1}return f}*run(I){this.counter=0;f:while(this.counter<I.length){if(yield this.counter,this.waitTicks>0){this.waitTicks--;break}let q=I[this.counter];if(typeof q.operation==="string"){let f=this.customOpCodes.get(q.operation);if(f){let F={variableMemory:this.variableMemory,procVariableMemory:this.procVariableMemory,procLock:this.procLock,getVar:(H,G)=>this.variableCheck(H,G),setVar:(H,G)=>this.setVariableMemory(H,G)};f(q.args,F)}else throw new Error(`Unknown opcode '${q.operation}' at line ${q.line}. Make sure the required module is imported.`)}else switch(q.operation){case 0:{let f=this.variableCheck(q.args[0],q.line);this.setVariableMemory(q.args[2],f);break}case 12:{let f=this.variableCheck(q.args[0],q.line);this.setVariableMemory(q.args[0],f+1);break}case 13:{let f=this.variableCheck(q.args[0],q.line);this.setVariableMemory(q.args[0],f-1);break}case 14:{this.variableMemory.delete(q.args[0]);break}case 16:{this.buffer.push(`DUMPING MEMORY at line ${q.line}`);for(let[f,F]of this.variableMemory.entries())this.buffer.push(`${f}: ${F}`);this.buffer.push("END OF MEMORY DUMP");break}case 15:break;case 17:{this.setVariableMemory(q.args[0],this.counter);break}case 2:{let f=this.variableCheck(q.args[0],q.line);if(Number.isNaN(f))throw new Error("Invalid print operation at line "+q.line);else this.buffer.push(f.toString());break}case 3:{let f=q.args[0];this.buffer.push(f.toString());break}case 1:{let{args:f,line:F}=q,H=new Map([["+",(z,J)=>z+J],["-",(z,J)=>z-J],["*",(z,J)=>z*J],["/",(z,J)=>z/J],["%",(z,J)=>z%J],["**",(z,J)=>Math.pow(z,J)],["min",(z,J)=>Math.min(z,J)],["max",(z,J)=>Math.max(z,J)]]),G=new Map([["sqrt",(z)=>Math.sqrt(z)],["log",(z)=>Math.log(z)],["floor",(z)=>Math.floor(z)],["ceil",(z)=>Math.ceil(z)],["sin",(z)=>Math.sin(z)],["rand",(z)=>Math.random()*z],["cos",(z)=>Math.cos(z)],["tan",(z)=>Math.tan(z)],["abs",(z)=>Math.abs(z)],["round",(z)=>Math.round(z)],["log10",(z)=>Math.log10(z)],["exp",(z)=>Math.exp(z)]]),K=f[1],Q,L;if(H.has(K)){if(f.length!==5||f[3]!==">>")throw new Error(`Invalid syntax for binary math operation at line ${F}. Expected: MATH var1 op var2 >> result`);let z=this.variableCheck(f[0],F),J=this.variableCheck(f[2],F);L=f[4],Q=H.get(K)(z,J)}else if(G.has(K)){if(f.length!==4||f[2]!==">>")throw new Error(`Invalid syntax for unary math operation at line ${F}. Expected: MATH var1 op >> result`);let z=this.variableCheck(f[0],F);L=f[3],Q=G.get(K)(z)}else throw new Error(`Unknown math operator "${K}" at line ${F}`);if(Number.isNaN(Q))throw new Error(`Math operation resulted in NaN at line ${F}. Check for invalid inputs like sqrt(-1) or 0/0.`);else this.setVariableMemory(L,Q);break}case 6:{let f=q.args,F=this.variableCheck(f[0],q.line),H=this.variableCheck(f[2],q.line),G=!1;switch(f[1]){case">":G=F>H;break;case"<":G=F<H;break;case"==":G=F==H;break;case"!=":G=F!=H;break;case">=":G=F>=H;break;case"<=":G=F<=H;break;default:throw new Error(`Invalid comparison operator at line ${q.line}`)}if(G)this.counter=this.jumpPointCheck(f[4],q.line)-1;break}case 7:break f;case 5:{let f=this.jumpPointCheck(q.args[0],this.counter);this.counter=f-1;break}case 8:{if(this.procLock){if(q.args.length>0)this.procReturn=this.variableCheck(q.args[0],q.line)}break}case 4:break;case 10:{let f=q.args;if(!this.procLock){let F=this.procPointCheck(f[0],this.counter);this.counter=F[1]-1}else{let F=f[1].split(",");for(let H=0;H<F.length;H++)this.setVariableMemory(F[H].trim(),this.procArgs[H])}break}case 19:{if(this.procLock){if(this.procReturnValueTarget)this.variableMemory.set(this.procReturnValueTarget,this.procReturn);this.procLock=!1,this.procArgs=[],this.procVariableMemory.clear(),this.procReturnValueTarget=null,this.procReturn=0,this.counter=this.procLastLocation}break}case 9:{let f=q.args;if(f[2]===">>"&&f[3])this.procReturnValueTarget=f[3];this.procLock=!0,this.procLastLocation=this.counter;let F=f[1].split(",");if(F.length>0&&F[0]!=="")for(let H of F)this.procArgs.push(this.variableCheck(H.trim(),q.line));this.counter=this.procPointCheck(f[0],q.line)[0]-1;break}case 11:{let f=q.args;if(f[0])this.waitTicks=this.variableCheck(f[0],q.line);break}case 18:{let f=q.args[0];if(this.importedModules.has(f)){this.buffer.push(`Module '${f}' already imported`);break}this.buffer.push(`Module '${f}' imported successfully`),this.importedModules.add(f);break}default:throw new Error(`Unknown operation at line ${q.line}`)}this.counter++}return 0}resetVM(){this.variableMemory.clear(),this.jumpPoints.clear(),this.procPoints.clear(),this.buffer=[],this.procLock=!1,this.procVariableMemory.clear(),this.procArgs=[],this.procLastLocation=0,this.procReturn=0,this.procReturnValueTarget=null,this.waitTicks=0,this.counter=0,this.importedModules.clear()}getBuffer(){return this.buffer}getVariableMemory(){return this.variableMemory}loadModule(I,q){if(this.importedModules.has(I))return;if(q&&typeof q.registerWith==="function")q.registerWith(this),this.importedModules.add(I);else throw new Error(`Module '${I}' does not export a registerWith function`)}}function W(){return new U}export{W as createVM,U as PanSparkVM};
