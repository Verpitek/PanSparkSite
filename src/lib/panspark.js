var K=(H)=>({type:0,value:H}),I=(H)=>({type:1,value:H}),G=(H)=>({type:2,value:H}),X;((U)=>{U[U.SET=0]="SET";U[U.MATH=1]="MATH";U[U.PRINT=2]="PRINT";U[U.ECHO=3]="ECHO";U[U.POINT=4]="POINT";U[U.JUMP=5]="JUMP";U[U.IF=6]="IF";U[U.END=7]="END";U[U.RETURN=8]="RETURN";U[U.CALL=9]="CALL";U[U.PROC=10]="PROC";U[U.WAIT=11]="WAIT";U[U.INC=12]="INC";U[U.DEC=13]="DEC";U[U.FREE=14]="FREE";U[U.NOP=15]="NOP";U[U.MEMDUMP=16]="MEMDUMP";U[U.TICK=17]="TICK";U[U.IMPORT=18]="IMPORT";U[U["}"]=19]="}";U[U.LIST_CREATE=20]="LIST_CREATE";U[U.LIST_SET=21]="LIST_SET";U[U.LIST_GET=22]="LIST_GET";U[U.LIST_PUSH=23]="LIST_PUSH";U[U.LIST_SORT=24]="LIST_SORT"})(X||={});class _{pool=[];allocate(){let H=this.pool.pop();if(H)return H.variableMemory.clear(),H.returnLocation=0,H.returnValueTarget=null,H.procStartLine=0,H.procEndLine=0,H.procName="",H.args=[],H;return{variableMemory:new Map,returnLocation:0,returnValueTarget:null,procStartLine:0,procEndLine:0,procName:"",args:[]}}free(H){this.pool.push(H)}clear(){this.pool=[]}}var R=/"([^"]*)"|\[([^\]]*)\]|\s*>>\s*(\S+)|\(([^)]*)\)|(\S+)/g;class z{jumpPoints=new Map;procPoints=new Map;variableMemory=new Map;buffer=[];procStack=[];framePool=new _;procReturn=K(0);shouldReturn=!1;waitTicks=0;counter=0;customOpCodes=new Map;importedModules=new Set;binaryMathOps=new Map([["%",(H,q)=>H%q],["**",(H,q)=>Math.pow(H,q)],["min",(H,q)=>Math.min(H,q)],["max",(H,q)=>Math.max(H,q)]]);unaryMathOps=new Map([["sqrt",(H)=>Math.sqrt(H)],["log",(H)=>Math.log(H)],["floor",(H)=>Math.floor(H)],["ceil",(H)=>Math.ceil(H)],["sin",(H)=>Math.sin(H)],["rand",(H)=>Math.random()*H],["cos",(H)=>Math.cos(H)],["tan",(H)=>Math.tan(H)],["abs",(H)=>Math.abs(H)],["round",(H)=>Math.round(H)],["log10",(H)=>Math.log10(H)],["exp",(H)=>Math.exp(H)]]);constructor(){}registerOpCode(H,q){this.customOpCodes.set(H.toUpperCase(),q)}get procLock(){return this.procStack.length>0}get procVariableMemory(){if(this.procStack.length===0)return new Map;return this.procStack[this.procStack.length-1].variableMemory}getCurrentProcBoundaries(){if(this.procStack.length===0)return null;let H=this.procStack[this.procStack.length-1];return[H.procStartLine,H.procEndLine]}setVariableMemory(H,q){if(this.procLock){this.procVariableMemory.set(H,q);return}this.variableMemory.set(H,q)}variableCheck(H,q){if(this.procLock){let Q=this.procVariableMemory.get(H);if(Q!==void 0)return Q}let D=this.variableMemory.get(H);if(D!==void 0)return D;let J=Number(H);if(!isNaN(J))return{type:0,value:J};throw new Error(`Variable "${H}" is not defined at line ${q}`)}jumpPointCheck(H,q){let D=this.jumpPoints.get(H);if(D===void 0)throw new Error(`Jump point "${H}" is not defined at line ${q}.`);return D}safeJumpPointCheck(H,q){let D=this.jumpPointCheck(H,q);if(this.procLock){let J=this.getCurrentProcBoundaries();if(J){let[Q,W]=J;if(D<Q||D>W){let Y=this.procStack[this.procStack.length-1];throw new Error(`Cannot jump to "${H}" at line ${q}: Jump target is outside procedure "${Y.procName}" scope (procedure spans lines ${Q+1}-${W+1})`)}}}return D}procPointCheck(H,q){let D=this.procPoints.get(H);if(D===void 0)throw new Error(`Proc "${H}" is not defined at line ${q}.`);return D}compile(H){let q=H.split(`
`),D=[];this.jumpPoints.clear(),this.procPoints.clear();for(let W=0;W<q.length;W++){let Y=q[W].trim();if(Y===""||Y.startsWith("//"))continue;R.lastIndex=0;let Z=[],$;while(($=R.exec(Y))!==null)if($[1]!==void 0)Z.push($[1]);else if($[2]!==void 0)Z.push(`${$[2]}`);else if($[3]!==void 0)Z.push(">>",$[3]);else if($[4]!==void 0)Z.push($[4]);else Z.push($[5]);if(Z.length===0)continue;let L=Z[0].toUpperCase(),B=X[Z[0].toUpperCase()];if(B===void 0&&this.customOpCodes.has(L))B=L;if(B===void 0)B=L;let M={operation:B,args:Z.slice(1),line:W+1};if(typeof B==="string"&&this.customOpCodes.has(B))M.customHandler=this.customOpCodes.get(B);D.push(M)}let J={name:"",startLine:0,endLine:0},Q=!1;for(let W=0;W<D.length;W++){let Y=D[W];if(Y.operation===4)this.jumpPoints.set(Y.args[0],W);if(!Q){if(Y.operation===10)J={name:Y.args[0],startLine:W,endLine:0},Q=!0}if(Y.operation===19){if(!Q)throw new Error(`Unexpected '}' at line ${Y.line} without matching PROC`);J.endLine=W,this.procPoints.set(J.name,[J.startLine,J.endLine]),Q=!1}}if(Q)throw new Error(`Unclosed PROC "${J.name}" starting at line ${J.startLine+1}`);for(let W=0;W<D.length;W++){let Y=D[W];if(Y.operation===5&&Y.args.length>0){let Z=this.jumpPoints.get(Y.args[0]);if(Z!==void 0)Y.jumpTarget=Z}else if(Y.operation===6&&Y.args.length>=5){let Z=this.jumpPoints.get(Y.args[4]);if(Z!==void 0)Y.jumpTarget=Z}}return D}executeMath(H,q,D){switch(D){case"+":return H+q;case"-":return H-q;case"*":return H*q;case"/":return H/q;default:{let J=this.binaryMathOps.get(D);if(J)return J(H,q);throw new Error(`Unknown binary operator: ${D}`)}}}executeUnaryMath(H,q){let D=this.unaryMathOps.get(q);if(D)return D(H);throw new Error(`Unknown unary operator: ${q}`)}shouldBatchExecute(H,q){let D=0,J=Math.min(50,H.length-q);for(let Q=0;Q<J;Q++){let W=H[q+Q];if(W.operation===11||W.operation===5||W.operation===6||W.operation===9||W.operation===8||W.operation===7)break;D++}return D}*run(H){this.counter=0;q:while(this.counter<H.length){if(yield this.counter,this.waitTicks>0){this.waitTicks--;break}let q=H[this.counter];if(this.shouldReturn&&this.procLock){let D=this.getCurrentProcBoundaries();if(D){this.counter=D[1],this.shouldReturn=!1;continue}}if(typeof q.operation==="string"){let D=q.customHandler||this.customOpCodes.get(q.operation);if(D){let J={buffer:this.buffer,variableMemory:this.variableMemory,procVariableMemory:this.procVariableMemory,procLock:this.procLock,getVar:(Q,W)=>this.variableCheck(Q,W),setVar:(Q,W)=>this.setVariableMemory(Q,W)};D(q.args,J)}else throw new Error(`Unknown opcode '${q.operation}' at line ${q.line}. Make sure the required module is imported.`)}else switch(q.operation){case 0:{if(q.args.length===1)if(isNaN(Number(q.args[0])))this.setVariableMemory(q.args[0],K(0));else throw new Error(`Invalid variable name '${q.args[0]}' at line ${q.line}`);else{let D=this.variableCheck(q.args[0],q.line);this.setVariableMemory(q.args[2],D)}break}case 12:{let D=this.variableCheck(q.args[0],q.line);if(D.type!==0)throw new Error(`The provided variable is not a number at line ${q.line}`);this.setVariableMemory(q.args[0],K(D.value+1));break}case 13:{let D=this.variableCheck(q.args[0],q.line);if(D.type!==0)throw new Error(`The provided variable is not a number at line ${q.line}`);this.setVariableMemory(q.args[0],K(D.value-1));break}case 20:{let D=[];this.setVariableMemory(q.args[0],G(D));break}case 23:{let D=this.variableCheck(q.args[2],q.line),J=this.variableCheck(q.args[0],q.line);if(D.type!==2)throw new Error(`The provided variable is not a list at line ${q.line}`);if(J.type!==0)throw new Error(`The provided value is not a number at line ${q.line}`);D.value.push(J.value),this.setVariableMemory(q.args[2],D);break}case 22:{let D=this.variableCheck(q.args[0],q.line),J=this.variableCheck(q.args[1],q.line);if(D.type!==2)throw new Error(`The provided variable is not a list at line ${q.line}`);if(J.type!==0)throw new Error(`The provided index is not a number at line ${q.line}`);let Q=D.value[J.value];if(Q===void 0)throw new Error(`The provided index is out of bounds at line ${q.line}`);this.setVariableMemory(q.args[3],K(Q));break}case 21:{let D=this.variableCheck(q.args[3],q.line),J=this.variableCheck(q.args[1],q.line),Q=this.variableCheck(q.args[0],q.line);if(J.type!==0)throw new Error(`The provided index is not a number at line ${q.line}`);if(Q.type!==0)throw new Error(`The provided value is not a number at line ${q.line}`);if(D.type!==2)throw new Error(`The provided list is not a list at line ${q.line}`);D.value[J.value]=Q.value,this.setVariableMemory(q.args[3],D);break}case 24:{let D=this.variableCheck(q.args[0],q.line);if(D.type!==2)throw new Error(`The provided list is not a list at line ${q.line}`);if(q.args[1]==="min")D.value.sort((J,Q)=>J-Q);else if(q.args[1]==="max")D.value.sort((J,Q)=>Q-J);else throw new Error(`Invalid sort order at line ${q.line}`);break}case 14:{if(this.procLock)this.procVariableMemory.delete(q.args[0]);else this.variableMemory.delete(q.args[0]);break}case 16:{if(this.buffer.push(`DUMPING MEMORY at line ${q.line}`),this.procLock)if(this.buffer.push(`  [PROC "${this.procStack[this.procStack.length-1].procName}" LOCAL MEMORY - Depth: ${this.procStack.length}]`),this.procVariableMemory.size===0)this.buffer.push("    (empty)");else for(let[D,J]of this.procVariableMemory.entries())this.buffer.push(`    ${D}: ${J.value}`);if(this.buffer.push("  [GLOBAL MEMORY]"),this.variableMemory.size===0)this.buffer.push("    (empty)");else for(let[D,J]of this.variableMemory.entries())this.buffer.push(`    ${D}: ${J.value}`);this.buffer.push("END OF MEMORY DUMP");break}case 15:break;case 17:{this.setVariableMemory(q.args[0],K(this.counter));break}case 2:{let D=this.variableCheck(q.args[0],q.line);if(D.type===0)this.buffer.push(D.value.toString());else if(D.type===1)this.buffer.push(D.value);else if(D.type===2)this.buffer.push("["+D.value.toString()+"]");break}case 3:{this.buffer.push(q.args[0].toString());break}case 1:{let{args:D,line:J}=q,Q=D[1],W,Y;if(Q==="+"||Q==="-"||Q==="*"||Q==="/"||Q==="%"||Q==="**"||Q==="min"||Q==="max"){if(D.length!==5||D[3]!==">>")throw new Error(`Invalid syntax for binary math operation at line ${J}. Expected: MATH var1 op var2 >> result`);let Z=this.variableCheck(D[0],J),$=this.variableCheck(D[2],J);if(Y=D[4],Z.type===0&&$.type===0)W=this.executeMath(Z.value,$.value,Q);else throw new Error(`The provided variable is not a number at line ${q.line}`)}else{if(D.length!==4||D[2]!==">>")throw new Error(`Invalid syntax for unary math operation at line ${J}. Expected: MATH var1 op >> result`);let Z=this.variableCheck(D[0],J);if(Y=D[3],Z.type===0)W=this.executeUnaryMath(Z.value,Q);else throw new Error(`The provided variable is not a number at line ${q.line}`)}if(Number.isNaN(W))throw new Error(`Math operation resulted in NaN at line ${J}. Check for invalid inputs like sqrt(-1) or 0/0.`);else this.setVariableMemory(Y,K(W));break}case 6:{let D=q.args,J=this.variableCheck(D[0],q.line),Q=this.variableCheck(D[2],q.line),W,Y;if(J.type===0)W=J.value;else throw new Error(`Cannot compare non-numeric value at line ${q.line}`);if(Q.type===0)Y=Q.value;else throw new Error(`Cannot compare non-numeric value at line ${q.line}`);let Z=!1;switch(D[1]){case">":Z=W>Y;break;case"<":Z=W<Y;break;case"==":Z=W==Y;break;case"!=":Z=W!=Y;break;case">=":Z=W>=Y;break;case"<=":Z=W<=Y;break;default:throw new Error(`Invalid comparison operator "${D[1]}" at line ${q.line}`)}if(Z)if(q.jumpTarget!==void 0)this.counter=q.jumpTarget-1;else this.counter=this.safeJumpPointCheck(D[4],q.line)-1;break}case 7:break q;case 5:{if(q.jumpTarget!==void 0)this.counter=q.jumpTarget-1;else{let D=this.safeJumpPointCheck(q.args[0],q.line);this.counter=D-1}break}case 8:{if(this.procLock){if(q.args.length>0)this.procReturn=this.variableCheck(q.args[0],q.line);else this.procReturn=K(0);this.shouldReturn=!0}else throw new Error(`RETURN can only be used inside a procedure at line ${q.line}`);break}case 4:break;case 10:{let D=q.args;if(!this.procLock){let J=this.procPointCheck(D[0],this.counter);this.counter=J[1]-1}else{let J=D[1]||"",Q=J.trim()===""?[]:J.split(",").map((Z)=>Z.trim()),W=this.procStack[this.procStack.length-1],Y=W.args;if(Y.length!==Q.length)throw new Error(`Procedure "${W.procName}" expects ${Q.length} arguments but received ${Y.length} at line ${q.line}`);for(let Z=0;Z<Q.length;Z++)this.procVariableMemory.set(Q[Z],Y[Z])}break}case 19:{if(this.procLock){let D=this.procStack.pop();if(D.returnValueTarget)this.variableMemory.set(D.returnValueTarget,this.procReturn);this.procReturn=K(0),this.shouldReturn=!1,this.framePool.free(D),this.counter=D.returnLocation}break}case 9:{let D=q.args;if(D.length<2)throw new Error(`Invalid CALL syntax at line ${q.line}. Expected: CALL procName (args) or CALL procName (args) >> result`);let J=D[0],Q=this.procPointCheck(J,q.line),W=null;if(D.length>2&&D[2]===">>"&&D[3])W=D[3];let Y=D[1]||"",Z=Y.trim()===""?[]:Y.split(",").map((B)=>B.trim()),$=[];for(let B of Z)if(B!=="")$.push(this.variableCheck(B,q.line));let L=this.framePool.allocate();L.returnLocation=this.counter,L.returnValueTarget=W,L.procStartLine=Q[0],L.procEndLine=Q[1],L.procName=J,L.args=$,this.procStack.push(L),this.counter=Q[0]-1;break}case 11:{let D=q.args;if(D[0]){let J=this.variableCheck(D[0],q.line);if(J.type===0)this.waitTicks=Math.floor(J.value);else throw new Error(`WAIT requires a numeric value at line ${q.line}`)}break}case 18:{let D=q.args[0];if(this.importedModules.has(D)){this.buffer.push(`Module '${D}' already imported`);break}this.buffer.push(`Module '${D}' imported successfully`),this.importedModules.add(D);break}default:throw new Error(`Unknown operation ${q.operation} at line ${q.line}`)}this.counter++}return 0}resetVM(){this.variableMemory.clear(),this.jumpPoints.clear(),this.procPoints.clear(),this.buffer=[],this.procStack=[],this.framePool.clear(),this.procReturn=K(0),this.shouldReturn=!1,this.waitTicks=0,this.counter=0,this.importedModules.clear()}getBuffer(){return this.buffer}getVariableMemory(){return this.variableMemory}loadModule(H,q){if(this.importedModules.has(H))return;if(q&&typeof q.registerWith==="function")q.registerWith(this),this.importedModules.add(H);else throw new Error(`Module '${H}' does not export a registerWith function`)}}function w(){return new z}export{w as createVM,I as Str,z as PanSparkVM,K as Num,G as List};
