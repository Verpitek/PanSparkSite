var R=new Map,K=[new Map],S=[],T;((H)=>{H[H.SET=0]="SET";H[H.MATH=1]="MATH";H[H.PRINT=2]="PRINT";H[H.IF=3]="IF";H[H.JUMP=4]="JUMP";H[H.END=5]="END";H[H.RETURN=6]="RETURN";H[H.PROC=7]="PROC";H[H.ENDPROC=8]="ENDPROC"})(T||={});function J(G,w,D){for(let j=D;j>=0;j--){let q=K[j];if(q&&q.has(G)){q.set(G,w);return}}if(K[D]===void 0)K[D]=new Map;K[D].set(G,w)}function E(G,w,D){for(let q=D;q>=0;q--){let z=K[q];if(z&&z.has(G))return z.get(G)}let j=Number(G);if(!isNaN(j))return j;throw new Error(`Variable "${G}" is not defined at line ${w}`)}function Q(G,w){if(R.has(G)){let D=R.get(G);if(D!=null)return[!0,D];else throw new Error("proc point "+G+" is not defined at line "+w)}else throw new Error("proc point "+G+" is not defined at line "+w)}function U(G){let w=G.split(`
`),D=[];for(let j=0;j<w.length;j++){let q=w[j].trimLeft();if(q.trim()===""||q.startsWith("//"))continue;let z=q.split(" "),B=T[z[0].toUpperCase()];D.push({operation:B,args:z.slice(1),line:j+1})}return D}async function W(G){let w=0;for(let D=0;D<G.length;D++){let j=G[D];if(j.operation===7)R.set(j.args[0],D)}j:for(let D=0;D<G.length;D++){let j=G[D];switch(j.operation){case 0:{let q=E(j.args[0],j.line,w);if(q!==void 0&&!Number.isNaN(q)){if(!K[w])K[w]=new Map;K[w].set(j.args[2],q)}else throw new Error("Invalid variable name at line "+j.line);break}case 2:{let q=j.args[0],z=E(j.args[0],j.line,w);if(Number.isNaN(z))throw new Error("Invalid print operation at line "+j.line);else S.push(z.toString());break}case 1:{let q=j.args;switch(q[1]){case"+":{let z=E(q[0],j.line,w),B=E(q[2],j.line,w),F=z+B;if(Number.isNaN(F))throw new Error("Invalid operation at line "+j.line);else J(q[4],z+B,w);break}case"-":{let z=E(q[0],j.line,w),B=E(q[2],j.line,w),F=z-B;if(Number.isNaN(F))throw new Error("Invalid operation at line "+j.line);else J(q[4],F,w);break}case"*":{let z=E(q[0],j.line,w),B=E(q[2],j.line,w),F=z*B;if(Number.isNaN(F))throw new Error("Invalid operation at line "+j.line);else J(q[4],F,w);break}case"/":{let z=E(q[0],j.line,w),B=E(q[2],j.line,w),F=z/B;if(Number.isNaN(F))throw new Error("Invalid operation at line "+j.line);else J(q[4],F,w);break}case"%":{let z=E(q[0],j.line,w),B=E(q[2],j.line,w),F=z%B;if(Number.isNaN(F))throw new Error("Invalid operation at line "+j.line);else J(q[4],F,w);break}case"**":{let z=E(q[0],j.line,w),B=E(q[2],j.line,w),F=Math.pow(z,B);if(Number.isNaN(F))throw new Error("Invalid operation at line "+j.line);else J(q[4],F,w);break}case"sqrt":{let z=E(q[0],j.line,w),B=Math.sqrt(z);if(Number.isNaN(B))throw new Error("Invalid operation at line "+j.line);else J(q[3],B,w);break}case"log":{let z=E(q[0],j.line,w),B=Math.log(z);if(Number.isNaN(B))throw new Error("Invalid operation at line "+j.line);else J(q[3],B,w);break}case"rand":{let z=E(q[0],j.line,w),B=Math.random()*z;if(Number.isNaN(B))throw new Error("Invalid operation at line "+j.line);else J(q[3],B,w);break}case"floor":{let z=E(q[0],j.line,w),B=Math.floor(z);if(Number.isNaN(B))throw new Error("Invalid operation at line "+j.line);else J(q[3],B,w);break}case"ceil":{let z=E(q[0],j.line,w),B=Math.ceil(z);if(Number.isNaN(B))throw new Error("Invalid operation at line "+j.line);else J(q[3],B,w);break}case"sin":{let z=E(q[0],j.line,w),B=Math.sin(z);if(Number.isNaN(B))throw new Error("Invalid operation at line "+j.line);else J(q[3],B,w);break}default:throw new Error("invalid math operator at line "+j.line)}break}case 3:{let q=j.args;switch(q[1]){case">":{let z=E(q[0],j.line,w),B=E(q[2],j.line,w),F=z>B;if(Number.isNaN(z)||Number.isNaN(B))throw new Error("invalid > comparison at line "+j.line);else if(F){let I=Q(q[4],D);if(I[0]===!0)D=I[1]-1}break}case"<":{let z=E(q[0],j.line,w),B=E(q[2],j.line,w),F=z<B;if(Number.isNaN(z)||Number.isNaN(B))throw new Error("invalid < comparison at line "+j.line);else if(F){let I=Q(q[4],D);if(I[0]===!0)D=I[1]-1}break}case"==":{let z=E(q[0],j.line,w),B=E(q[2],j.line,w),F=z==B;if(Number.isNaN(z)||Number.isNaN(B))throw new Error("invalid == comparison at line "+j.line);else if(F){let I=Q(q[4],D);if(I[0]===!0)D=I[1]-1}break}case"!=":{let z=E(q[0],j.line,w),B=E(q[2],j.line,w),F=z!=B;if(Number.isNaN(z)||Number.isNaN(B))throw new Error("invalid != comparison at line "+j.line);else if(F){let I=Q(q[4],D);if(I[0]===!0)D=I[1]-1}break}case">=":{let z=E(q[0],j.line,w),B=E(q[2],j.line,w),F=z>=B;if(Number.isNaN(z)||Number.isNaN(B))throw new Error("invalid >=comparison at line "+j.line);else if(F){let I=Q(q[4],D);if(I[0]===!0)D=I[1]-1}break}case"<=":{let z=E(q[0],j.line,w),B=E(q[2],j.line,w),F=z<=B;if(Number.isNaN(z)||Number.isNaN(B))throw new Error("invalid <=comparison at line "+j.line);else if(F){let I=Q(q[4],D);if(I[0]===!0)D=I[1]-1}break}default:throw new Error("invalid comparison operator at line "+j.line)}break}case 5:break j;case 4:{let q=Q(j.args[0],D);if(q[0]===!0)D=q[1]-1;break}case 6:{let q=E(j.args[0],j.line,w);if(Number.isNaN(q))throw new Error("Invalid return operation at line "+j.line);else return q}case 7:{w++;break}case 8:{w--;break}default:S.push("Invalid operation");break}}return 0}function X(){K=[new Map],R.clear(),S=[]}export{W as run,X as resetVM,R as procPoints,K as memory,U as compile,S as buffer};
