var X=(J)=>({type:0,value:J}),j=(J)=>({type:1,value:J}),E=(J)=>({type:2,value:J}),D;((W)=>{W[W.SET=0]="SET";W[W.MATH=1]="MATH";W[W.PRINT=2]="PRINT";W[W.ECHO=3]="ECHO";W[W.POINT=4]="POINT";W[W.JUMP=5]="JUMP";W[W.IF=6]="IF";W[W.END=7]="END";W[W.RETURN=8]="RETURN";W[W.CALL=9]="CALL";W[W.PROC=10]="PROC";W[W.WAIT=11]="WAIT";W[W.INC=12]="INC";W[W.DEC=13]="DEC";W[W.FREE=14]="FREE";W[W.NOP=15]="NOP";W[W.MEMDUMP=16]="MEMDUMP";W[W.TICK=17]="TICK";W[W.IMPORT=18]="IMPORT";W[W.ENDPROC=19]="ENDPROC";W[W.FOR=20]="FOR";W[W.ENDFOR=21]="ENDFOR";W[W.BREAK=22]="BREAK";W[W.CONTINUE=23]="CONTINUE";W[W.LIST_CREATE=24]="LIST_CREATE";W[W.LIST_SET=25]="LIST_SET";W[W.LIST_GET=26]="LIST_GET";W[W.LIST_PUSH=27]="LIST_PUSH";W[W.LIST_SORT=28]="LIST_SORT"})(D||={});class w{pool=[];allocate(){let J=this.pool.pop();if(J)return J.variableMemory.clear(),J.returnLocation=0,J.returnValueTarget=null,J.procStartLine=0,J.procEndLine=0,J.procName="",J.args=[],J;return{variableMemory:new Map,returnLocation:0,returnValueTarget:null,procStartLine:0,procEndLine:0,procName:"",args:[]}}free(J){this.pool.push(J)}clear(){this.pool=[]}}var L=/"([^"]*)"|\[([^\]]*)\]|\s*>>\s*(\S+)|\(([^)]*)\)|(\S+)/g;class y{jumpPoints=new Map;procPoints=new Map;variableMemory=new Map;buffer=[];procStack=[];forStack=[];framePool=new w;procReturn=X(0);shouldReturn=!1;waitTicks=0;counter=0;customOpCodes=new Map;importedModules=new Set;binaryMathOps=new Map([["%",(J,q)=>J%q],["**",(J,q)=>Math.pow(J,q)],["min",(J,q)=>Math.min(J,q)],["max",(J,q)=>Math.max(J,q)]]);unaryMathOps=new Map([["sqrt",(J)=>Math.sqrt(J)],["log",(J)=>Math.log(J)],["floor",(J)=>Math.floor(J)],["ceil",(J)=>Math.ceil(J)],["sin",(J)=>Math.sin(J)],["rand",(J)=>Math.random()*J],["cos",(J)=>Math.cos(J)],["tan",(J)=>Math.tan(J)],["abs",(J)=>Math.abs(J)],["round",(J)=>Math.round(J)],["log10",(J)=>Math.log10(J)],["exp",(J)=>Math.exp(J)]]);constructor(){}evaluateExpression(J,q){J=J.replace(/\s+/g,"");let H=(Z)=>["+","-","*","/","%"].includes(Z),Q=[],U="",Y=0;for(let Z=0;Z<J.length;Z++){let B=J[Z];if(B==="(")Y++,U+=B;else if(B===")")Y--,U+=B;else if(H(B)&&Y===0){if(U)Q.push(U);Q.push(B),U=""}else U+=B}if(U)Q.push(U);let $=Q.map((Z)=>{if(H(Z))return Z;if(Z.startsWith("(")&&Z.endsWith(")"))return this.evaluateExpression(Z.slice(1,-1),q);let B=Number(Z);if(!isNaN(B))return B;let M=this.variableCheck(Z,q);if(M.type!==0)throw new Error(`Variable "${Z}" is not a number at line ${q}`);return M.value});return((Z)=>{let B=0;while(B<Z.length)if(Z[B]==="*"||Z[B]==="/"||Z[B]==="%"){let M=Z[B-1],R=Z[B],_=Z[B+1],z;if(R==="*")z=M*_;else if(R==="/")z=M/_;else z=M%_;Z.splice(B-1,3,z)}else B++;B=0;while(B<Z.length)if(Z[B]==="+"||Z[B]==="-"){let M=Z[B-1],R=Z[B],_=Z[B+1],z=R==="+"?M+_:M-_;Z.splice(B-1,3,z)}else B++;return Z[0]})($)}registerOpCode(J,q){this.customOpCodes.set(J.toUpperCase(),q)}get procLock(){return this.procStack.length>0}get procVariableMemory(){if(this.procStack.length===0)return new Map;return this.procStack[this.procStack.length-1].variableMemory}getCurrentProcBoundaries(){if(this.procStack.length===0)return null;let J=this.procStack[this.procStack.length-1];return[J.procStartLine,J.procEndLine]}setVariableMemory(J,q){if(this.procLock){this.procVariableMemory.set(J,q);return}this.variableMemory.set(J,q)}variableCheck(J,q){if(this.procLock){let U=this.procVariableMemory.get(J);if(U!==void 0)return U}let H=this.variableMemory.get(J);if(H!==void 0)return H;let Q=Number(J);if(!isNaN(Q))return{type:0,value:Q};throw new Error(`Variable "${J}" is not defined at line ${q}`)}jumpPointCheck(J,q){let H=this.jumpPoints.get(J);if(H===void 0)throw new Error(`Jump point "${J}" is not defined at line ${q}.`);return H}safeJumpPointCheck(J,q){let H=this.jumpPointCheck(J,q);if(this.procLock){let Q=this.getCurrentProcBoundaries();if(Q){let[U,Y]=Q;if(H<U||H>Y){let $=this.procStack[this.procStack.length-1];throw new Error(`Cannot jump to "${J}" at line ${q}: Jump target is outside procedure "${$.procName}" scope (procedure spans lines ${U+1}-${Y+1})`)}}}return H}procPointCheck(J,q){let H=this.procPoints.get(J);if(H===void 0)throw new Error(`Proc "${J}" is not defined at line ${q}.`);return H}compile(J){let q=J.split(`
`),H=[];this.jumpPoints.clear(),this.procPoints.clear();for(let Y=0;Y<q.length;Y++){let $=q[Y].trim();if($===""||$.startsWith("//"))continue;L.lastIndex=0;let K=[],Z;while((Z=L.exec($))!==null)if(Z[1]!==void 0)K.push(Z[1]);else if(Z[2]!==void 0)K.push(`${Z[2]}`);else if(Z[3]!==void 0)K.push(">>",Z[3]);else if(Z[4]!==void 0)K.push(Z[4]);else K.push(Z[5]);if(K.length===0)continue;let B=0;for(let z=0;z<H.length;z++){let G=H[z];if(G.operation===20)B++;if(G.operation===21){if(B--,B<0)throw new Error(`Unexpected ENDFOR at line ${G.line} without matching FOR`)}}let M=K[0].toUpperCase(),R=D[K[0].toUpperCase()];if(R===void 0&&this.customOpCodes.has(M))R=M;if(R===void 0)R=M;let _={operation:R,args:K.slice(1),line:Y+1};if(typeof R==="string"&&this.customOpCodes.has(R))_.customHandler=this.customOpCodes.get(R);H.push(_)}let Q={name:"",startLine:0,endLine:0},U=!1;for(let Y=0;Y<H.length;Y++){let $=H[Y];if($.operation===4)this.jumpPoints.set($.args[0],Y);if(!U){if($.operation===10)Q={name:$.args[0],startLine:Y,endLine:0},U=!0}if($.operation===19){if(!U)throw new Error(`Unexpected '}' at line ${$.line} without matching PROC`);Q.endLine=Y,this.procPoints.set(Q.name,[Q.startLine,Q.endLine]),U=!1}}if(U)throw new Error(`Unclosed PROC "${Q.name}" starting at line ${Q.startLine+1}`);for(let Y=0;Y<H.length;Y++){let $=H[Y];if($.operation===5&&$.args.length>0){let K=this.jumpPoints.get($.args[0]);if(K!==void 0)$.jumpTarget=K}else if($.operation===6&&$.args.length>=5){let K=this.jumpPoints.get($.args[4]);if(K!==void 0)$.jumpTarget=K}}return H}executeMath(J,q,H){switch(H){case"+":return J+q;case"-":return J-q;case"*":return J*q;case"/":return J/q;default:{let Q=this.binaryMathOps.get(H);if(Q)return Q(J,q);throw new Error(`Unknown binary operator: ${H}`)}}}executeUnaryMath(J,q){let H=this.unaryMathOps.get(q);if(H)return H(J);throw new Error(`Unknown unary operator: ${q}`)}shouldBatchExecute(J,q){let H=0,Q=Math.min(50,J.length-q);for(let U=0;U<Q;U++){let Y=J[q+U];if(Y.operation===11||Y.operation===5||Y.operation===6||Y.operation===9||Y.operation===8||Y.operation===7)break;H++}return H}*run(J){this.counter=0;q:while(this.counter<J.length){if(yield this.counter,this.waitTicks>0){this.waitTicks--;break}let q=J[this.counter];if(this.shouldReturn&&this.procLock){let H=this.getCurrentProcBoundaries();if(H){this.counter=H[1],this.shouldReturn=!1;continue}}if(typeof q.operation==="string"){let H=q.customHandler||this.customOpCodes.get(q.operation);if(H){let Q={buffer:this.buffer,variableMemory:this.variableMemory,procVariableMemory:this.procVariableMemory,procLock:this.procLock,getVar:(U,Y)=>this.variableCheck(U,Y),setVar:(U,Y)=>this.setVariableMemory(U,Y)};H(q.args,Q)}else throw new Error(`Unknown opcode '${q.operation}' at line ${q.line}. Make sure the required module is imported.`)}else switch(q.operation){case 0:{if(q.args.length===1)if(isNaN(Number(q.args[0])))this.setVariableMemory(q.args[0],X(0));else throw new Error(`Invalid variable name '${q.args[0]}' at line ${q.line}`);else{let H=this.variableCheck(q.args[0],q.line);this.setVariableMemory(q.args[2],H)}break}case 12:{let H=this.variableCheck(q.args[0],q.line);if(H.type!==0)throw new Error(`The provided variable is not a number at line ${q.line}`);this.setVariableMemory(q.args[0],X(H.value+1));break}case 13:{let H=this.variableCheck(q.args[0],q.line);if(H.type!==0)throw new Error(`The provided variable is not a number at line ${q.line}`);this.setVariableMemory(q.args[0],X(H.value-1));break}case 24:{let H=[];this.setVariableMemory(q.args[0],E(H));break}case 27:{let H=this.variableCheck(q.args[2],q.line),Q=this.variableCheck(q.args[0],q.line);if(H.type!==2)throw new Error(`The provided variable is not a list at line ${q.line}`);if(Q.type!==0)throw new Error(`The provided value is not a number at line ${q.line}`);H.value.push(Q.value),this.setVariableMemory(q.args[2],H);break}case 26:{let H=this.variableCheck(q.args[0],q.line),Q=this.variableCheck(q.args[1],q.line);if(H.type!==2)throw new Error(`The provided variable is not a list at line ${q.line}`);if(Q.type!==0)throw new Error(`The provided index is not a number at line ${q.line}`);let U=H.value[Q.value];if(U===void 0)throw new Error(`The provided index is out of bounds at line ${q.line}`);this.setVariableMemory(q.args[3],X(U));break}case 25:{let H=this.variableCheck(q.args[3],q.line),Q=this.variableCheck(q.args[1],q.line),U=this.variableCheck(q.args[0],q.line);if(Q.type!==0)throw new Error(`The provided index is not a number at line ${q.line}`);if(U.type!==0)throw new Error(`The provided value is not a number at line ${q.line}`);if(H.type!==2)throw new Error(`The provided list is not a list at line ${q.line}`);H.value[Q.value]=U.value,this.setVariableMemory(q.args[3],H);break}case 28:{let H=this.variableCheck(q.args[0],q.line);if(H.type!==2)throw new Error(`The provided list is not a list at line ${q.line}`);if(q.args[1]==="min")H.value.sort((Q,U)=>Q-U);else if(q.args[1]==="max")H.value.sort((Q,U)=>U-Q);else throw new Error(`Invalid sort order at line ${q.line}`);break}case 14:{if(this.procLock)this.procVariableMemory.delete(q.args[0]);else this.variableMemory.delete(q.args[0]);break}case 16:{if(this.buffer.push(`DUMPING MEMORY at line ${q.line}`),this.procLock)if(this.buffer.push(`  [PROC "${this.procStack[this.procStack.length-1].procName}" LOCAL MEMORY - Depth: ${this.procStack.length}]`),this.procVariableMemory.size===0)this.buffer.push("    (empty)");else for(let[H,Q]of this.procVariableMemory.entries())this.buffer.push(`    ${H}: ${Q.value}`);if(this.buffer.push("  [GLOBAL MEMORY]"),this.variableMemory.size===0)this.buffer.push("    (empty)");else for(let[H,Q]of this.variableMemory.entries())this.buffer.push(`    ${H}: ${Q.value}`);this.buffer.push("END OF MEMORY DUMP");break}case 15:break;case 17:{this.setVariableMemory(q.args[0],X(this.counter));break}case 2:{let H=this.variableCheck(q.args[0],q.line);if(H.type===0)this.buffer.push(H.value.toString());else if(H.type===1)this.buffer.push(H.value);else if(H.type===2)this.buffer.push("["+H.value.toString()+"]");break}case 3:{this.buffer.push(q.args[0].toString());break}case 1:{let{args:H,line:Q}=q,U=H.indexOf(">>");if(U===-1||U===H.length-1)throw new Error(`Invalid MATH syntax at line ${Q}. Expected: MATH expression >> result`);let Y=H[U+1],$=H.slice(0,U);if($.length===2){let B=$[1];if(this.unaryMathOps.has(B)){let M=this.variableCheck($[0],Q);if(M.type!==0)throw new Error(`The provided variable is not a number at line ${Q}`);let R=this.executeUnaryMath(M.value,B);this.setVariableMemory(Y,X(R));break}}if($.length===3){let B=$[1];if(["+","-","*","/","%","**","min","max"].includes(B)){let M=this.variableCheck($[0],Q),R=this.variableCheck($[2],Q);if(M.type!==0||R.type!==0)throw new Error(`The provided variables are not numbers at line ${Q}`);let _=this.executeMath(M.value,R.value,B);this.setVariableMemory(Y,X(_));break}}let K=$.join(" "),Z=this.evaluateExpression(K,Q);if(Number.isNaN(Z))throw new Error(`Math operation resulted in NaN at line ${Q}`);this.setVariableMemory(Y,X(Z));break}case 6:{let H=q.args,Q=this.variableCheck(H[0],q.line),U=this.variableCheck(H[2],q.line),Y,$;if(Q.type===0)Y=Q.value;else throw new Error(`Cannot compare non-numeric value at line ${q.line}`);if(U.type===0)$=U.value;else throw new Error(`Cannot compare non-numeric value at line ${q.line}`);let K=!1;switch(H[1]){case">":K=Y>$;break;case"<":K=Y<$;break;case"==":K=Y==$;break;case"!=":K=Y!=$;break;case">=":K=Y>=$;break;case"<=":K=Y<=$;break;default:throw new Error(`Invalid comparison operator "${H[1]}" at line ${q.line}`)}if(K)if(q.jumpTarget!==void 0)this.counter=q.jumpTarget-1;else this.counter=this.safeJumpPointCheck(H[4],q.line)-1;break}case 7:break q;case 5:{if(q.jumpTarget!==void 0)this.counter=q.jumpTarget-1;else{let H=this.safeJumpPointCheck(q.args[0],q.line);this.counter=H-1}break}case 8:{if(this.procLock){if(q.args.length>0)this.procReturn=this.variableCheck(q.args[0],q.line);else this.procReturn=X(0);this.shouldReturn=!0}else throw new Error(`RETURN can only be used inside a procedure at line ${q.line}`);break}case 4:break;case 10:{let H=q.args;if(!this.procLock){let Q=this.procPointCheck(H[0],this.counter);this.counter=Q[1]-1}else{let Q=H[1]||"",U=Q.trim()===""?[]:Q.split(",").map((K)=>K.trim()),Y=this.procStack[this.procStack.length-1],$=Y.args;if($.length!==U.length)throw new Error(`Procedure "${Y.procName}" expects ${U.length} arguments but received ${$.length} at line ${q.line}`);for(let K=0;K<U.length;K++)this.procVariableMemory.set(U[K],$[K])}break}case 19:{if(this.procLock){let H=this.procStack.pop();if(H.returnValueTarget)this.variableMemory.set(H.returnValueTarget,this.procReturn);this.procReturn=X(0),this.shouldReturn=!1,this.framePool.free(H),this.counter=H.returnLocation}break}case 20:{let H=q.args;if(H.length<3)throw new Error(`Invalid FOR syntax at line ${q.line}. Expected: FOR variable start end`);let Q=H[0],U=this.variableCheck(H[1],q.line),Y=this.variableCheck(H[2],q.line);if(U.type!==0||Y.type!==0)throw new Error(`FOR loop bounds must be numbers at line ${q.line}`);if(Y.value<U.value)throw new Error(`Invalid FOR loop at line ${q.line}. End value must be >= start value`);let $=-1,K=0;for(let Z=this.counter+1;Z<J.length;Z++){if(J[Z].operation===20)K++;if(J[Z].operation===21){if(K===0){$=Z;break}K--}}if($===-1)throw new Error(`FOR loop at line ${q.line} has no matching ENDFOR`);this.setVariableMemory(Q,X(U.value)),this.forStack.push({varName:Q,endValue:Y.value,forStartLine:this.counter,endForLine:$});break}case 21:{if(this.forStack.length===0)throw new Error(`ENDFOR without matching FOR at line ${q.line}`);let H=this.forStack[this.forStack.length-1],Q=this.variableCheck(H.varName,q.line);if(Q.type!==0)throw new Error(`Loop variable must be a number at line ${q.line}`);let U=Q.value+1;if(U<=H.endValue)this.setVariableMemory(H.varName,X(U)),this.counter=H.forStartLine;else this.forStack.pop();break}case 22:{if(this.forStack.length===0)throw new Error(`BREAK can only be used inside a FOR loop at line ${q.line}`);let H=this.forStack.pop();this.counter=H.endForLine;break}case 23:{if(this.forStack.length===0)throw new Error(`CONTINUE can only be used inside a FOR loop at line ${q.line}`);let H=this.forStack[this.forStack.length-1],Q=this.variableCheck(H.varName,q.line);if(Q.type!==0)throw new Error(`Loop variable must be a number at line ${q.line}`);let U=Q.value+1;if(U<=H.endValue)this.setVariableMemory(H.varName,X(U)),this.counter=H.forStartLine;else this.forStack.pop(),this.counter=H.endForLine;break}case 9:{let H=q.args;if(H.length<2)throw new Error(`Invalid CALL syntax at line ${q.line}. Expected: CALL procName (args) or CALL procName (args) >> result`);let Q=H[0],U=this.procPointCheck(Q,q.line),Y=null;if(H.length>2&&H[2]===">>"&&H[3])Y=H[3];let $=H[1]||"",K=$.trim()===""?[]:$.split(",").map((M)=>M.trim()),Z=[];for(let M of K)if(M!=="")Z.push(this.variableCheck(M,q.line));let B=this.framePool.allocate();B.returnLocation=this.counter,B.returnValueTarget=Y,B.procStartLine=U[0],B.procEndLine=U[1],B.procName=Q,B.args=Z,this.procStack.push(B),this.counter=U[0]-1;break}case 11:{let H=q.args;if(H[0]){let Q=this.variableCheck(H[0],q.line);if(Q.type===0)this.waitTicks=Math.floor(Q.value);else throw new Error(`WAIT requires a numeric value at line ${q.line}`)}break}case 18:{let H=q.args[0];if(this.importedModules.has(H)){this.buffer.push(`Module '${H}' already imported`);break}this.buffer.push(`Module '${H}' imported successfully`),this.importedModules.add(H);break}default:throw new Error(`Unknown operation ${q.operation} at line ${q.line}`)}this.counter++}return 0}resetVM(){this.variableMemory.clear(),this.jumpPoints.clear(),this.procPoints.clear(),this.buffer=[],this.forStack=[],this.procStack=[],this.forStack=[],this.framePool.clear(),this.procReturn=X(0),this.shouldReturn=!1,this.waitTicks=0,this.counter=0,this.importedModules.clear()}getBuffer(){return this.buffer}getVariableMemory(){return this.variableMemory}loadModule(J,q){if(this.importedModules.has(J))return;if(q&&typeof q.registerWith==="function")q.registerWith(this),this.importedModules.add(J);else throw new Error(`Module '${J}' does not export a registerWith function`)}}function F(){return new y}export{F as createVM,j as Str,y as PanSparkVM,X as Num,E as List};
