var T=new Map,f=new Map,Z=new Map,z=[],S=!1,_=new Map,X=[],x=0,Y=0,W=null,M;((w)=>{w[w.SET=0]="SET";w[w.MATH=1]="MATH";w[w.PRINT=2]="PRINT";w[w.ECHO=3]="ECHO";w[w.IF=4]="IF";w[w.JUMP=5]="JUMP";w[w.END=6]="END";w[w.RETURN=7]="RETURN";w[w.POINT=8]="POINT";w[w.CALL=9]="CALL";w[w.PROC=10]="PROC";w[w["}"]=11]="}"})(M||={});function $(I,G){if(S){_.set(I,G);return}Z.set(I,G)}function Q(I,G){if(S){let E=_.get(I);if(E!==void 0)return E}let B=Z.get(I);if(B!==void 0)return B;let D=Number(I);if(!isNaN(D))return D;throw new Error(`Variable "${I}" is not defined at line ${G}`)}function R(I,G){let B=T.get(I);if(B===void 0)throw new Error(`Jump point "${I}" is not defined at line ${G}.`);return B}function j(I,G){let B=f.get(I);if(B===void 0)throw new Error(`Proc "${I}" is not defined at line ${G}.`);return B}function y(I){let G=I.split(`
`),B=[];for(let F=0;F<G.length;F++){let H=G[F].trim();if(H===""||H.startsWith("//"))continue;let U=/"([^"]*)"|\s*>>\s*(\S+)|\(([^)]*)\)|(\S+)/g,K=[],J;while((J=U.exec(H))!==null)if(J[1]!==void 0)K.push(J[1]);else if(J[2]!==void 0)K.push(">>",J[2]);else K.push(J[3]||J[4]);let q=M[K[0].toUpperCase()];B.push({operation:q,args:K.slice(1),line:F+1})}for(let F=0;F<B.length;F++){let H=B[F];if(H.operation===8)T.set(H.args[0],F)}let D={name:"",startLine:0,endLine:0},E=!1;for(let F=0;F<B.length;F++){let H=B[F];if(!E){if(H.operation===10)D={name:H.args[0],startLine:F,endLine:0},E=!0}if(H.operation===11)D.endLine=F,f.set(D.name,[D.startLine,D.endLine]),E=!1}return B}function*N(I){let G=0;q:while(G<I.length){yield G;let B=I[G];switch(B.operation){case 0:{let D=Q(B.args[0],B.line);$(B.args[2],D);break}case 2:{let D=B.args[0],E=Q(B.args[0],B.line);if(Number.isNaN(E))throw new Error("Invalid print operation at line "+B.line);else z.push(E.toString());break}case 3:{let D=B.args[0];z.push(D.toString());break}case 1:{let{args:D,line:E}=B,F=new Map([["+",(q,w)=>q+w],["-",(q,w)=>q-w],["*",(q,w)=>q*w],["/",(q,w)=>q/w],["%",(q,w)=>q%w],["**",(q,w)=>Math.pow(q,w)],["min",(q,w)=>Math.min(q,w)],["max",(q,w)=>Math.max(q,w)]]),H=new Map([["sqrt",(q)=>Math.sqrt(q)],["log",(q)=>Math.log(q)],["floor",(q)=>Math.floor(q)],["ceil",(q)=>Math.ceil(q)],["sin",(q)=>Math.sin(q)],["rand",(q)=>Math.random()*q],["cos",(q)=>Math.cos(q)],["tan",(q)=>Math.tan(q)],["abs",(q)=>Math.abs(q)],["round",(q)=>Math.round(q)],["log10",(q)=>Math.log10(q)],["exp",(q)=>Math.exp(q)]]),U=D[1],K,J;if(F.has(U)){if(D.length!==5||D[3]!==">>")throw new Error(`Invalid syntax for binary math operation at line ${E}. Expected: MATH var1 op var2 >> result`);let q=Q(D[0],E),w=Q(D[2],E);J=D[4],K=F.get(U)(q,w)}else if(H.has(U)){if(D.length!==4||D[2]!==">>")throw new Error(`Invalid syntax for unary math operation at line ${E}. Expected: MATH var1 op >> result`);let q=Q(D[0],E);J=D[3],K=H.get(U)(q)}else throw new Error(`Unknown math operator "${U}" at line ${E}`);if(Number.isNaN(K))throw new Error(`Math operation resulted in NaN at line ${E}. Check for invalid inputs like sqrt(-1) or 0/0.`);else $(J,K);break}case 4:{let D=B.args,E=Q(D[0],B.line),F=Q(D[2],B.line),H=!1;switch(D[1]){case">":H=E>F;break;case"<":H=E<F;break;case"==":H=E==F;break;case"!=":H=E!=F;break;case">=":H=E>=F;break;case"<=":H=E<=F;break;default:throw new Error(`Invalid comparison operator at line ${B.line}`)}if(H)G=R(D[4],B.line)-1;break}case 6:break q;case 5:{G=R(B.args[0],G)-1;break}case 7:{if(S){if(B.args.length>0)Y=Q(B.args[0],B.line)}break}case 8:break;case 10:{let D=B.args;if(!S)G=j(D[0],G)[1]-1;else{let E=D[1].split(",");for(let F=0;F<E.length;F++)$(E[F].trim(),X[F])}break}case 11:{if(S){if(W)Z.set(W,Y);S=!1,X=[],_.clear(),W=null,Y=0,G=x}break}case 9:{let D=B.args;if(D[2]===">>"&&D[3])W=D[3];S=!0,x=G;let E=D[1].split(",");if(E.length>0&&E[0]!=="")for(let F of E)X.push(Q(F.trim(),B.line));G=j(D[0],B.line)[0]-1;break}default:throw new Error(`Unknown operation at line ${B.line}`)}G++}return 0}function V(){Z=new Map,T.clear(),f.clear(),z=[],S=!1,_.clear(),X=[],x=0,Y=0,W=null}export{Z as variableMemory,N as run,V as resetVM,_ as procVariableMemory,W as procReturnValueTarget,Y as procReturn,f as procPoints,S as procLock,x as procLastLocation,X as procArgs,T as jumpPoints,y as compile,z as buffer};
