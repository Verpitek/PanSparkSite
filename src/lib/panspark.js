var T=new Map,f=new Map,X=new Map,z=[],S=!1,Y=new Map,_=[],x=0,$=0,W=null,R=new Map;function N(I,G){R.set(I.toUpperCase(),G)}var L;((q)=>{q[q.SET=0]="SET";q[q.MATH=1]="MATH";q[q.PRINT=2]="PRINT";q[q.ECHO=3]="ECHO";q[q.IF=4]="IF";q[q.JUMP=5]="JUMP";q[q.END=6]="END";q[q.RETURN=7]="RETURN";q[q.POINT=8]="POINT";q[q.CALL=9]="CALL";q[q.PROC=10]="PROC";q[q["}"]=11]="}"})(L||={});function Z(I,G){if(S){Y.set(I,G);return}X.set(I,G)}function Q(I,G){if(S){let F=Y.get(I);if(F!==void 0)return F}let B=X.get(I);if(B!==void 0)return B;let D=Number(I);if(!isNaN(D))return D;throw new Error(`Variable "${I}" is not defined at line ${G}`)}function j(I,G){let B=T.get(I);if(B===void 0)throw new Error(`Jump point "${I}" is not defined at line ${G}.`);return B}function M(I,G){let B=f.get(I);if(B===void 0)throw new Error(`Proc "${I}" is not defined at line ${G}.`);return B}function V(I){let G=I.split(`
`),B=[];for(let E=0;E<G.length;E++){let H=G[E].trim();if(H===""||H.startsWith("//"))continue;let U=/"([^"]*)"|\s*>>\s*(\S+)|\(([^)]*)\)|(\S+)/g,J=[],K;while((K=U.exec(H))!==null)if(K[1]!==void 0)J.push(K[1]);else if(K[2]!==void 0)J.push(">>",K[2]);else J.push(K[3]||K[4]);let w=J[0].toUpperCase(),q=L[J[0].toUpperCase()];if(q===void 0&&R.has(w))q=w;if(q===void 0)throw new Error(`Unknown operation "${J[0]}" at line ${E+1}`);B.push({operation:q,args:J.slice(1),line:E+1})}for(let E=0;E<B.length;E++){let H=B[E];if(H.operation===8)T.set(H.args[0],E)}let D={name:"",startLine:0,endLine:0},F=!1;for(let E=0;E<B.length;E++){let H=B[E];if(!F){if(H.operation===10)D={name:H.args[0],startLine:E,endLine:0},F=!0}if(H.operation===11)D.endLine=E,f.set(D.name,[D.startLine,D.endLine]),F=!1}return B}function*P(I){let G=0;q:while(G<I.length){yield G;let B=I[G];if(typeof B.operation==="string"){let D=R.get(B.operation);if(D){let F={variableMemory:X,procVariableMemory:Y,procLock:S,getVar:(E,H)=>Q(E,H),setVar:(E,H)=>Z(E,H)};D(B.args,F)}}else switch(B.operation){case 0:{let D=Q(B.args[0],B.line);Z(B.args[2],D);break}case 2:{let D=B.args[0],F=Q(B.args[0],B.line);if(Number.isNaN(F))throw new Error("Invalid print operation at line "+B.line);else z.push(F.toString());break}case 3:{let D=B.args[0];z.push(D.toString());break}case 1:{let{args:D,line:F}=B,E=new Map([["+",(w,q)=>w+q],["-",(w,q)=>w-q],["*",(w,q)=>w*q],["/",(w,q)=>w/q],["%",(w,q)=>w%q],["**",(w,q)=>Math.pow(w,q)],["min",(w,q)=>Math.min(w,q)],["max",(w,q)=>Math.max(w,q)]]),H=new Map([["sqrt",(w)=>Math.sqrt(w)],["log",(w)=>Math.log(w)],["floor",(w)=>Math.floor(w)],["ceil",(w)=>Math.ceil(w)],["sin",(w)=>Math.sin(w)],["rand",(w)=>Math.random()*w],["cos",(w)=>Math.cos(w)],["tan",(w)=>Math.tan(w)],["abs",(w)=>Math.abs(w)],["round",(w)=>Math.round(w)],["log10",(w)=>Math.log10(w)],["exp",(w)=>Math.exp(w)]]),U=D[1],J,K;if(E.has(U)){if(D.length!==5||D[3]!==">>")throw new Error(`Invalid syntax for binary math operation at line ${F}. Expected: MATH var1 op var2 >> result`);let w=Q(D[0],F),q=Q(D[2],F);K=D[4],J=E.get(U)(w,q)}else if(H.has(U)){if(D.length!==4||D[2]!==">>")throw new Error(`Invalid syntax for unary math operation at line ${F}. Expected: MATH var1 op >> result`);let w=Q(D[0],F);K=D[3],J=H.get(U)(w)}else throw new Error(`Unknown math operator "${U}" at line ${F}`);if(Number.isNaN(J))throw new Error(`Math operation resulted in NaN at line ${F}. Check for invalid inputs like sqrt(-1) or 0/0.`);else Z(K,J);break}case 4:{let D=B.args,F=Q(D[0],B.line),E=Q(D[2],B.line),H=!1;switch(D[1]){case">":H=F>E;break;case"<":H=F<E;break;case"==":H=F==E;break;case"!=":H=F!=E;break;case">=":H=F>=E;break;case"<=":H=F<=E;break;default:throw new Error(`Invalid comparison operator at line ${B.line}`)}if(H)G=j(D[4],B.line)-1;break}case 6:break q;case 5:{G=j(B.args[0],G)-1;break}case 7:{if(S){if(B.args.length>0)$=Q(B.args[0],B.line)}break}case 8:break;case 10:{let D=B.args;if(!S)G=M(D[0],G)[1]-1;else{let F=D[1].split(",");for(let E=0;E<F.length;E++)Z(F[E].trim(),_[E])}break}case 11:{if(S){if(W)X.set(W,$);S=!1,_=[],Y.clear(),W=null,$=0,G=x}break}case 9:{let D=B.args;if(D[2]===">>"&&D[3])W=D[3];S=!0,x=G;let F=D[1].split(",");if(F.length>0&&F[0]!=="")for(let E of F)_.push(Q(E.trim(),B.line));G=M(D[0],B.line)[0]-1;break}default:throw new Error(`Unknown operation at line ${B.line}`)}G++}return 0}function A(){X=new Map,T.clear(),f.clear(),z=[],S=!1,Y.clear(),_=[],x=0,$=0,W=null}export{X as variableMemory,P as run,A as resetVM,N as registerOpCode,Y as procVariableMemory,W as procReturnValueTarget,$ as procReturn,f as procPoints,S as procLock,x as procLastLocation,_ as procArgs,T as jumpPoints,R as customOpCodes,V as compile,z as buffer};
